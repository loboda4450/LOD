<html lang="pl">

<head>
    <title> lodzik </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script type="text/javascript">
        let gl;
        let shaderProgram;
        let uPMatrix;
        let vertexPositionBuffer = [];
        let vertexColorBuffer = [];
        let vertexCoordsBuffer = [];
        let vertexNormalBuffer = [];
        let mouse_sensitivity = 1 / 30;
        let stages = 15; //reduce this value to notice bigger differences between lod stages
        let difference = 10;
        let textureImg = new Image();

        function MatrixTransposeInverse(m) {
            let r = [
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
            ];
            r[0] = m[5] * m[10] * m[15] - m[5] * m[14] * m[11] - m[6] * m[9] * m[15] + m[6] * m[13] * m[11] + m[7] * m[9] * m[14] - m[7] * m[13] * m[10];
            r[1] = -m[1] * m[10] * m[15] + m[1] * m[14] * m[11] + m[2] * m[9] * m[15] - m[2] * m[13] * m[11] - m[3] * m[9] * m[14] + m[3] * m[13] * m[10];
            r[2] = m[1] * m[6] * m[15] - m[1] * m[14] * m[7] - m[2] * m[5] * m[15] + m[2] * m[13] * m[7] + m[3] * m[5] * m[14] - m[3] * m[13] * m[6];
            r[3] = -m[1] * m[6] * m[11] + m[1] * m[10] * m[7] + m[2] * m[5] * m[11] - m[2] * m[9] * m[7] - m[3] * m[5] * m[10] + m[3] * m[9] * m[6];

            r[4] = -m[4] * m[10] * m[15] + m[4] * m[14] * m[11] + m[6] * m[8] * m[15] - m[6] * m[12] * m[11] - m[7] * m[8] * m[14] + m[7] * m[12] * m[10];
            r[5] = m[0] * m[10] * m[15] - m[0] * m[14] * m[11] - m[2] * m[8] * m[15] + m[2] * m[12] * m[11] + m[3] * m[8] * m[14] - m[3] * m[12] * m[10];
            r[6] = -m[0] * m[6] * m[15] + m[0] * m[14] * m[7] + m[2] * m[4] * m[15] - m[2] * m[12] * m[7] - m[3] * m[4] * m[14] + m[3] * m[12] * m[6];
            r[7] = m[0] * m[6] * m[11] - m[0] * m[10] * m[7] - m[2] * m[4] * m[11] + m[2] * m[8] * m[7] + m[3] * m[4] * m[10] - m[3] * m[8] * m[6];

            r[8] = m[4] * m[9] * m[15] - m[4] * m[13] * m[11] - m[5] * m[8] * m[15] + m[5] * m[12] * m[11] + m[7] * m[8] * m[13] - m[7] * m[12] * m[9];
            r[9] = -m[0] * m[9] * m[15] + m[0] * m[13] * m[11] + m[1] * m[8] * m[15] - m[1] * m[12] * m[11] - m[3] * m[8] * m[13] + m[3] * m[12] * m[9];
            r[10] = m[0] * m[5] * m[15] - m[0] * m[13] * m[7] - m[1] * m[4] * m[15] + m[1] * m[12] * m[7] + m[3] * m[4] * m[13] - m[3] * m[12] * m[5];
            r[11] = -m[0] * m[5] * m[11] + m[0] * m[9] * m[7] + m[1] * m[4] * m[11] - m[1] * m[8] * m[7] - m[3] * m[4] * m[9] + m[3] * m[8] * m[5];

            r[12] = -m[4] * m[9] * m[14] + m[4] * m[13] * m[10] + m[5] * m[8] * m[14] - m[5] * m[12] * m[10] - m[6] * m[8] * m[13] + m[6] * m[12] * m[9];
            r[13] = m[0] * m[9] * m[14] - m[0] * m[13] * m[10] - m[1] * m[8] * m[14] + m[1] * m[12] * m[10] + m[2] * m[8] * m[13] - m[2] * m[12] * m[9];
            r[14] = -m[0] * m[5] * m[14] + m[0] * m[13] * m[6] + m[1] * m[4] * m[14] - m[1] * m[12] * m[6] - m[2] * m[4] * m[13] + m[2] * m[12] * m[5];
            r[15] = m[0] * m[5] * m[10] - m[0] * m[9] * m[6] - m[1] * m[4] * m[10] + m[1] * m[8] * m[6] + m[2] * m[4] * m[9] - m[2] * m[8] * m[5];

            let det = m[0] * r[0] + m[1] * r[4] + m[2] * r[8] + m[3] * r[12];
            for (var i = 0; i < 16; i++) r[i] /= det;

            return [r[0], r[4], r[8], r[12],
                r[1], r[5], r[9], r[13],
                r[2], r[6], r[10], r[14],
                r[3], r[7], r[11], r[15]
            ];
        }

        function MatrixMul(a, b) {
            let c = [
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0,
                0, 0, 0, 0
            ]
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    c[i * 4 + j] = 0.0;
                    for (let k = 0; k < 4; k++) {
                        c[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return c;
        }

        function createRect2(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, p4x, p4y, p4z) {

            return [p1x, p1y, p1z, p2x, p2y, p2z, p4x, p4y, p4z,
                p1x, p1y, p1z, p4x, p4y, p4z, p3x, p3y, p3z];
        }

        function createRectCoords(mu, mv, dau, dav, dbu, dbv) {
            let p1u = mu;
            p1v = mv;
            let p2u = mu + dau;
            p2v = mv + dav;
            let p3u = mu + dbu;
            p3v = mv + dbv;
            let p4u = mu + dau + dbu;
            p4v = mv + dav + dbv;


            return [p1u, p1v, p2u, p2v, p4u, p4v,
                p1u, p1v, p4u, p4v, p3u, p3v];
        }

        function createRectColor(r, g, b) {

            return [r, g, b, r, g, b, r, g, b,
                r, g, b, r, g, b, r, g, b];
        }

        function CreateSphere(x, y, z, radius, numStepsElevation, numStepsAngle) {
            let vertexPosition = [];
            let vertexNormal = [];
            let vertexColor = [];
            let vertexCoords = [];

            let stepElevation = 90 / numStepsElevation;
            let stepAngle = 360 / numStepsAngle;
            for (let elevation = -90; elevation < 90; elevation += stepElevation) {
                let radiusXZ = radius * Math.cos(elevation * Math.PI / 180);
                let radiusY = radius * Math.sin(elevation * Math.PI / 180);

                let radiusXZ2 = radius * Math.cos((elevation + stepElevation) * Math.PI / 180);
                let radiusY2 = radius * Math.sin((elevation + stepElevation) * Math.PI / 180);

                for (let angle = 0; angle < 360; angle += stepAngle) {

                    let px1 = radiusXZ * Math.cos(angle * Math.PI / 180);
                    let py1 = radiusY;
                    let pz1 = radiusXZ * Math.sin(angle * Math.PI / 180);

                    let px2 = radiusXZ * Math.cos((angle + stepAngle) * Math.PI / 180);
                    let py2 = radiusY;
                    let pz2 = radiusXZ * Math.sin((angle + stepAngle) * Math.PI / 180);

                    let px3 = radiusXZ2 * Math.cos(angle * Math.PI / 180);
                    let py3 = radiusY2;
                    let pz3 = radiusXZ2 * Math.sin(angle * Math.PI / 180);

                    let px4 = radiusXZ2 * Math.cos((angle + stepAngle) * Math.PI / 180);
                    let py4 = radiusY2;
                    let pz4 = radiusXZ2 * Math.sin((angle + stepAngle) * Math.PI / 180);

                    vertexPosition.push(...createRect2(px1 + x, py1 + y, pz1 + z, px2 + x, py2 + y, pz2 + z, px3 + x, py3 + y, pz3 + z, px4 + x, py4 + y, pz4 + z));

                    let p1 = Math.sqrt(px1 * px1 + py1 * py1 + pz1 * pz1)
                    let p2 = Math.sqrt(px2 * px2 + py2 * py2 + pz2 * pz2)
                    let p3 = Math.sqrt(px3 * px3 + py3 * py3 + pz3 * pz3)
                    let p4 = Math.sqrt(px4 * px4 + py4 * py4 + pz4 * pz4)

                    px1 /= p1
                    py1 /= p1
                    pz1 /= p1

                    px2 /= p2
                    py2 /= p2
                    pz2 /= p2

                    px3 /= p3
                    py3 /= p3
                    pz3 /= p3

                    px4 /= p4
                    py4 /= p4
                    pz4 /= p4

                    vertexNormal.push(...createRect2(px1, py1, pz1, px2, py2, pz2, px3, py3, pz3, px4, py4, pz4));

                    vertexColor.push(...createRectColor(1.0, 1.0, 1.0));

                    vertexCoords.push(...createRectCoords(angle / 360.0, (elevation + 90.0) / 180.0, (stepAngle) / 360.0, 0.0, 0.0, (stepElevation) / 180.0));
                }
            }

            return [vertexPosition, vertexColor, vertexCoords, vertexNormal];
        }

        function updateMousePosition(e) {
            angleY += e.movementX * mouse_sensitivity;

            angleX += e.movementY * mouse_sensitivity;
        }

        function lockChangeAlert() {
            let canvas = document.getElementById('canvas3D');
            if (document.pointerLockElement === canvas ||
                document.mozPointerLockElement === canvas) {
                document.addEventListener("mousemove", updateMousePosition, false);
                console.log('The pointer lock status is now locked');
            } else {
                console.log('The pointer lock status is now unlocked');
                document.removeEventListener("mousemove", updateMousePosition, false);
            }
        }

        function startGL() {
            let canvas = document.getElementById("canvas3D");
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
            canvas.onclick = function () {
                canvas.requestPointerLock();
            }
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
            document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
            gl = canvas.getContext("webgl2");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;

            const vertextShaderSource = `
            precision highp float;
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
            attribute vec2 aVertexCoords;
            attribute vec3 aVertexNormal;
            uniform mat4 uVMatrix;
            uniform mat4 uMMatrix;
            uniform mat4 uMMatrix2;
            uniform mat4 uPMatrix;
            varying vec3 vPos;
            varying vec3 vColor;
            varying vec2 vTexUV;
            varying vec3 vNormal;
            void main(void) {
              vec4 tmp = uMMatrix * vec4(aVertexPosition, 1.0);
              gl_Position = uPMatrix * uVMatrix * tmp;
              vPos = tmp.xyz/tmp.w;
              vColor = aVertexColor;
              vTexUV = aVertexCoords;
              vNormal = normalize(mat3(uMMatrix2) * aVertexNormal);
            }
        `;
            const fragmentShaderSource = `
            precision highp float;
            varying vec3 vPos;
            varying vec3 vColor;
            varying vec2 vTexUV;
            varying vec3 vNormal;
            uniform sampler2D uSampler;
            uniform vec3 uLightPosition;
            void main(void) {
              vec3 lightDirection = normalize(uLightPosition - vPos);
              float brightness = max(dot(vNormal,lightDirection), 0.0);
              gl_FragColor = clamp(texture2D(uSampler,vTexUV) * vec4(brightness,brightness,brightness,1.0),0.0,1.0);
            }
        `;
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.shaderSource(vertexShader, vertextShaderSource);
            gl.compileShader(fragmentShader);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(fragmentShader));
                return null;
            }
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(vertexShader));
                return null;
            }

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) alert("Could not initialise shaders");

            let vertexPosition = [];
            let vertexColor = [];
            let vertexCoords = [];
            let vertexNormal = [];


            [vertexPosition[0], vertexColor[0], vertexCoords[0], vertexNormal[0]] = CreateSphere(0, 0, 0, 2, 1, 4);

            for (var i = 1; i < stages; i++) {
                [vertexPosition[i], vertexColor[i], vertexCoords[i], vertexNormal[i]] = CreateSphere(0, 0, 0, 2, 1 + difference * i, 6 * i + 1);
            }

            for (var i = 0; i < vertexPosition.length; i++) {
                vertexPositionBuffer[i] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer[i]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPosition[i]), gl.STATIC_DRAW);
                vertexPositionBuffer[i].itemSize = 3;
                vertexPositionBuffer[i].numItems = vertexPosition[i].length / 9;

                vertexColorBuffer[i] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer[i]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexColor[i]), gl.STATIC_DRAW);
                vertexColorBuffer[i].itemSize = 3;
                vertexColorBuffer[i].numItems = vertexColor[i].length / 9;

                vertexCoordsBuffer[i] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer[i]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexCoords[i]), gl.STATIC_DRAW);
                vertexCoordsBuffer[i].itemSize = 2;
                vertexCoordsBuffer[i].numItems = vertexCoords[i].length / 6;

                vertexNormalBuffer[i] = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer[i]);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormal[i]), gl.STATIC_DRAW);
                vertexNormalBuffer[i].itemSize = 3;
                vertexNormalBuffer[i].numItems = vertexNormal[i].length / 9;
            }


            textureBuffer = gl.createTexture();
            textureImg.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg.src = "sun.jpg";

            textureBuffer2 = gl.createTexture();
            var textureImg2 = new Image();
            textureImg2.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer2);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg2);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg2.src = "mercury.jpg";

            textureBuffer3 = gl.createTexture();
            var textureImg3 = new Image();
            textureImg3.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer3);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg3);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg3.src = "venus.jpg";

            textureBuffer4 = gl.createTexture();
            var textureImg4 = new Image();
            textureImg4.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer4);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg4);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg4.src = "earth.jpg";

            textureBuffer5 = gl.createTexture();
            var textureImg5 = new Image();
            textureImg5.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer5);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg5);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg5.src = "mars.jpg";

            textureBuffer6 = gl.createTexture();
            var textureImg6 = new Image();
            textureImg6.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer6);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg6);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg6.src = "jupiter.jpg";

            textureBuffer7 = gl.createTexture();
            var textureImg7 = new Image();
            textureImg7.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer7);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg7);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg7.src = "saturn.jpg";

            textureBuffer8 = gl.createTexture();
            var textureImg8 = new Image();
            textureImg8.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer8);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg8);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg8.src = "uranus.jpg";

            textureBuffer9 = gl.createTexture();
            var textureImg9 = new Image();
            textureImg9.onload = function () {
                gl.bindTexture(gl.TEXTURE_2D, textureBuffer9);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImg9);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            textureImg9.src = "neptune.jpg";

            let aspect = gl.viewportWidth / gl.viewportHeight;
            let fov = 45.0 * Math.PI / 180.0;
            let zFar = 500.0;
            let zNear = 0.1;
            uPMatrix = [
                1.0 / (aspect * Math.tan(fov / 2)), 0, 0, 0,
                0, 1.0 / (Math.tan(fov / 2)), 0, 0,
                0, 0, -(zFar + zNear) / (zFar - zNear), -1,
                0, 0, -(2 * zFar * zNear) / (zFar - zNear), 0.0,
            ];


            var el = document.createElement('div');
            el.setAttribute('id', 'lightPos');
            el.setAttribute('style', "float:right;");
            document.body.prepend(el);
            Tick();
        }

        let angleZ = 0.0;
        let angleY = 0.0;
        let angleX = 0.0;
        let tz = -20.0;
        let helptz;
        let tx = 0;
        let ty = 0;
        let lod = 3;
        let stepStage;

        let object1x = 0.0;
        let object1y = 0.0;
        let object1z = -0.0;

        let object2x = -3.0;
        let object2y = 0.0;
        let object2z = -0.0;

        let object3x = -5.0;
        let object3y = 0.0;
        let object3z = -0.0;

        let object4x = -7.0;
        let object4y = 0.0;
        let object4z = -0.0;

        let object5x = -9.0;
        let object5y = 0.0;
        let object5z = -0.0;

        let object6x = -11.0;
        let object6y = 0.0;
        let object6z = -0.0;

        let object7x = -13.0;
        let object7y = 0.0;
        let object7z = -0.0;

        let object8x = -15.0;
        let object8y = 0.0;
        let object8z = -0.0;

        let object9x = -17.0;
        let object9y = 0.0;
        let object9z = -0.0;

        let scale1 = 1.0;
        let scale2 = 0.5;
        let scale3 = 0.5;
        let scale4 = 0.5;
        let scale5 = 0.5;
        let scale6 = 0.5;
        let scale7 = 0.5;
        let scale8 = 0.5;
        let scale9 = 0.5;

        let rotateMercury = 0;
        let rotateVenus = 0;
        let rotateEarth = 0;
        let rotateMars = 0;
        let rotateJupiter = 0;
        let rotateSaturn = 0;
        let rotateUranus = 0;
        let rotateNeptune = 0;

        let lightX = 0;
        let lightY = 0;
        let lightZ = 0;

        let angleMove1 = 0.0;
        let angleMove2 = 0.0;
        let angleMove3 = 0.0;
        let angleMove4 = 0.0;
        let angleMove5 = 0.0;
        let angleMove6 = 0.0;
        let angleMove7 = 0.0;
        let angleMove8 = 0.0;
        let dance = true; // dance like nobody's watchin


        function Tick() {
            rotateMercury += 0.01;
            rotateVenus -= 0.01;
            rotateEarth += 0.02;
            rotateMars += 0.016;
            rotateJupiter += 0.04;
            rotateSaturn += 0.035;
            rotateUranus += 0.02;
            rotateNeptune += 0.021;


            if (angleMove1 === 360) {
                angleMove1 = 0;
            } else {
                angleMove1 += 0.1 / 4;
                object2x += 0.3 / 4 * Math.sin(angleMove1);
                object2z += -0.3 / 4 * Math.cos(angleMove1);
            }
            if (angleMove2 === 360) {
                angleMove2 = 0;
            } else {
                angleMove2 += 0.1 / 2;
                object3x += 0.5 / 2 * Math.sin(angleMove2);
                object3z += -0.5 / 2 * Math.cos(angleMove2);
            }
            if (angleMove3 === 360) {
                angleMove3 = 0;
            } else {
                angleMove3 += 0.1 / 1.5;
                object4x += 0.7 / 1.5 * Math.sin(angleMove3);
                object4y += -0.7 / 1.5 * Math.cos(angleMove3);
            }
            if (angleMove4 === 360) {
                angleMove4 = 0;
            } else {
                angleMove4 += 0.1 / 4;
                object5x += 0.9 / 4 * Math.sin(angleMove4);
                object5z += -0.9 / 4 * Math.cos(angleMove4);
            }
            if (angleMove5 === 360) {
                angleMove5 = 0;
            } else {
                angleMove5 += 0.1 / 7;
                object6x += 1.1 / 7 * Math.sin(angleMove5);
                object6z -= -1.1 / 7 * Math.cos(angleMove5);
                //xD
                if (dance === false) {
                    dance = true;
                    object6y += 0.4;
                } else {
                    dance = false;
                    object6y -= 0.4;
                }
            }
            if (angleMove6 === 360) {
                angleMove6 = 0;
            } else {
                angleMove6 += 0.1 / 4;
                object7x += 1.3 / 4 * Math.sin(angleMove6);
                object7z += -1.3 / 4 * Math.cos(angleMove6);
            }
            if (angleMove7 === 360) {
                angleMove7 = 0;
            } else {
                angleMove7 += 0.1 / 4;
                object8x += 1.5 / 4 * Math.sin(angleMove7);
                object8z -= -1.5 / 4 * Math.cos(angleMove7);
                object8y += -1.5 / 4 * Math.cos(angleMove7);
            }
            if (angleMove8 === 360) {
                angleMove8 = 0;
            } else {
                angleMove8 += 0.1 / 4;
                object9x += 1.7 / 4 * Math.sin(angleMove8);
                object9z += -1.7 / 4 * Math.cos(angleMove8);
                object9y -= -1.7 / 4 * -Math.cos(angleMove8);
            }

            let uMVMatrix1 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uVMatrix = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix2 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix3 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix4 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix5 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix6 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix7 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix8 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVMatrix9 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVRotZ = [
                +Math.cos(angleZ * Math.PI / 180.0), +Math.sin(angleZ * Math.PI / 180.0), 0, 0,
                -Math.sin(angleZ * Math.PI / 180.0), +Math.cos(angleZ * Math.PI / 180.0), 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVRotY = [
                +Math.cos(angleY * Math.PI / 180.0), 0, -Math.sin(angleY * Math.PI / 180.0), 0,
                0, 1, 0, 0,
                +Math.sin(angleY * Math.PI / 180.0), 0, +Math.cos(angleY * Math.PI / 180.0), 0,
                0, 0, 0, 1
            ];

            let uMVRotY1 = [
                +Math.cos(rotateMercury), 0, -Math.sin(rotateMercury), 0,
                0, 1, 0, 0,
                +Math.sin(rotateMercury), 0, +Math.cos(rotateMercury), 0,
                0, 0, 0, 1
            ];

            let uMVRotY2 = [
                +Math.cos(rotateVenus), 0, -Math.sin(rotateVenus), 0,
                0, 1, 0, 0,
                +Math.sin(rotateVenus), 0, +Math.cos(rotateVenus), 0,
                0, 0, 0, 1
            ];

            let uMVRotY3 = [
                +Math.cos(rotateEarth), 0, -Math.sin(rotateEarth), 0,
                0, 1, 0, 0,
                +Math.sin(rotateEarth), 0, +Math.cos(rotateEarth), 0,
                0, 0, 0, 1
            ];

            let uMVTranslateAngle3 = [
                +Math.cos(30 * Math.PI / 180.0), +Math.sin(30 * Math.PI / 180.0), 0, 0,
                -Math.sin(30 * Math.PI / 180.0), +Math.cos(30 * Math.PI / 180.0), 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVRotY4 = [
                +Math.cos(rotateMars), 0, -Math.sin(rotateMars), 0,
                0, 1, 0, 0,
                +Math.sin(rotateMars), 0, +Math.cos(rotateMars), 0,
                0, 0, 0, 1
            ];

            let uMVRotY5 = [
                +Math.cos(rotateJupiter), 0, -Math.sin(rotateJupiter), 0,
                0, 1, 0, 0,
                +Math.sin(rotateJupiter), 0, +Math.cos(rotateJupiter), 0,
                0, 0, 0, 1
            ];

            let uMVRotY6 = [
                +Math.cos(rotateSaturn), 0, -Math.sin(rotateSaturn), 0,
                0, 1, 0, 0,
                +Math.sin(rotateSaturn), 0, +Math.cos(rotateSaturn), 0,
                0, 0, 0, 1
            ];

            let uMVTranslateAngle7 = [
                +Math.cos(265 * Math.PI / 180.0), +Math.sin(265 * Math.PI / 180.0), 0, 0,
                -Math.sin(265 * Math.PI / 180.0), +Math.cos(265 * Math.PI / 180.0), 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];

            let uMVRotY7 = [
                +Math.cos(rotateUranus), 0, -Math.sin(rotateUranus), 0,
                0, 1, 0, 0,
                +Math.sin(rotateUranus), 0, +Math.cos(rotateUranus), 0,
                0, 0, 0, 1
            ];

            let uMVRotY8 = [
                +Math.cos(rotateNeptune), 0, -Math.sin(rotateNeptune), 0,
                0, 1, 0, 0,
                +Math.sin(rotateNeptune), 0, +Math.cos(rotateNeptune), 0,
                0, 0, 0, 1
            ];

            let uMVRotX = [
                1, 0, 0, 0,
                0, +Math.cos(angleX * Math.PI / 180.0), +Math.sin(angleX * Math.PI / 180.0), 0,
                0, -Math.sin(angleX * Math.PI / 180.0), +Math.cos(angleX * Math.PI / 180.0), 0,
                0, 0, 0, 1
            ];

            let uMVTranslateZ = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                tx, ty, tz, 1
            ];

            let uMVScale1 = [
                scale1, 0, 0, 0,
                0, scale1, 0, 0,
                0, 0, scale1, 0,
                0, 0, 0, 1
            ];

            let uMVScale2 = [
                scale2, 0, 0, 0,
                0, scale2, 0, 0,
                0, 0, scale2, 0,
                0, 0, 0, 1
            ];

            let uMVScale3 = [
                scale3, 0, 0, 0,
                0, scale3, 0, 0,
                0, 0, scale3, 0,
                0, 0, 0, 1
            ];

            let uMVScale4 = [
                scale4, 0, 0, 0,
                0, scale4, 0, 0,
                0, 0, scale4, 0,
                0, 0, 0, 1
            ];

            let uMVScale5 = [
                scale5, 0, 0, 0,
                0, scale5, 0, 0,
                0, 0, scale5, 0,
                0, 0, 0, 1
            ];

            let uMVScale6 = [
                scale6, 0, 0, 0,
                0, scale6, 0, 0,
                0, 0, scale6, 0,
                0, 0, 0, 1
            ];

            let uMVScale7 = [
                scale7, 0, 0, 0,
                0, scale7, 0, 0,
                0, 0, scale7, 0,
                0, 0, 0, 1
            ];

            let uMVScale8 = [
                scale8, 0, 0, 0,
                0, scale8, 0, 0,
                0, 0, scale8, 0,
                0, 0, 0, 1
            ];

            let uMVScale9 = [
                scale9, 0, 0, 0,
                0, scale9, 0, 0,
                0, 0, scale9, 0,
                0, 0, 0, 1
            ];

            let uMVObject1 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object1x, object1y, object1z, 1
            ];

            let uMVObject2 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object2x, object2y, object2z, 1
            ];

            let uMVObject3 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object3x, object3y, object3z, 1
            ];

            let uMVObject4 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object4x, object4y, object4z, 1
            ];

            let uMVObject5 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object5x, object5y, object5z, 1
            ];

            let uMVObject6 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object6x, object6y, object6z, 1
            ];

            let uMVObject7 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object7x, object7y, object7z, 1
            ];

            let uMVObject8 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object8x, object8y, object8z, 1
            ];

            let uMVObject9 = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                object9x, object9y, object9z, 1
            ];


            uMVMatrix1 = MatrixMul(uMVMatrix1, uMVScale1);
            uMVMatrix1 = MatrixMul(uMVMatrix1, uMVObject1);
            uMVMatrix1 = MatrixMul(uMVMatrix1, uMVRotX);
            uMVMatrix1 = MatrixMul(uMVMatrix1, uMVRotY);
            uMVMatrix1 = MatrixMul(uMVMatrix1, uMVRotZ);
            uMVMatrix1 = MatrixMul(uMVMatrix1, uMVTranslateZ);

            uMVMatrix2 = MatrixMul(uMVMatrix2, uMVScale2);
            uMVMatrix2 = MatrixMul(uMVMatrix2, uMVRotY1);
            uMVMatrix2 = MatrixMul(uMVMatrix2, uMVObject2);
            uMVMatrix2 = MatrixMul(uMVMatrix2, uMVRotX);
            uMVMatrix2 = MatrixMul(uMVMatrix2, uMVRotY);
            uMVMatrix2 = MatrixMul(uMVMatrix2, uMVRotZ);
            uMVMatrix2 = MatrixMul(uMVMatrix2, uMVTranslateZ);

            uMVMatrix3 = MatrixMul(uMVMatrix3, uMVScale3);
            uMVMatrix3 = MatrixMul(uMVMatrix3, uMVRotY2);
            uMVMatrix3 = MatrixMul(uMVMatrix3, uMVObject3);
            uMVMatrix3 = MatrixMul(uMVMatrix3, uMVRotX);
            uMVMatrix3 = MatrixMul(uMVMatrix3, uMVRotY);
            uMVMatrix3 = MatrixMul(uMVMatrix3, uMVRotZ);
            uMVMatrix3 = MatrixMul(uMVMatrix3, uMVTranslateZ);

            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVScale4);
            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVRotY3);
            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVTranslateAngle3);
            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVObject4);
            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVRotX);
            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVRotY);
            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVRotZ);
            uMVMatrix4 = MatrixMul(uMVMatrix4, uMVTranslateZ);

            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVScale5);
            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVRotY4);
            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVTranslateAngle3);
            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVObject5);
            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVRotX);
            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVRotY);
            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVRotZ);
            uMVMatrix5 = MatrixMul(uMVMatrix5, uMVTranslateZ);

            uMVMatrix6 = MatrixMul(uMVMatrix6, uMVScale6);
            uMVMatrix6 = MatrixMul(uMVMatrix6, uMVRotY5);
            uMVMatrix6 = MatrixMul(uMVMatrix6, uMVObject6);
            uMVMatrix6 = MatrixMul(uMVMatrix6, uMVRotX);
            uMVMatrix6 = MatrixMul(uMVMatrix6, uMVRotY);
            uMVMatrix6 = MatrixMul(uMVMatrix6, uMVRotZ);
            uMVMatrix6 = MatrixMul(uMVMatrix6, uMVTranslateZ);

            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVScale7);
            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVRotY6);
            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVTranslateAngle3);
            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVObject7);
            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVRotX);
            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVRotY);
            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVRotZ);
            uMVMatrix7 = MatrixMul(uMVMatrix7, uMVTranslateZ);

            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVScale8);
            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVRotY7);
            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVTranslateAngle7);
            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVObject8);
            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVRotX);
            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVRotY);
            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVRotZ);
            uMVMatrix8 = MatrixMul(uMVMatrix8, uMVTranslateZ);

            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVScale9);
            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVRotY8);
            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVTranslateAngle3);
            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVObject9);
            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVRotX);
            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVRotY);
            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVRotZ);
            uMVMatrix9 = MatrixMul(uMVMatrix9, uMVTranslateZ);

            uVMatrix = MatrixMul(uVMatrix, uMVTranslateZ);

            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clearDepth(1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.useProgram(shaderProgram)
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uPMatrix"), false, new Float32Array(uPMatrix));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uVMatrix"), false, new Float32Array(uVMatrix.flat(1)));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix1));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix1)));

            tz < 0 ? helptz = -tz : helptz = tz;

            stepStage = 100 / (stages - 1);

            if (helptz >= 100) {
                lod = 0;
            } else {
                lod = stages - 1 - parseInt(helptz / stepStage);
            }
            console.log(lod);

            gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer[lod]);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), vertexPositionBuffer[lod].itemSize, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexColor"));
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer[lod]);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexColor"), vertexColorBuffer[lod].itemSize, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexCoords"));
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexCoordsBuffer[lod]);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexCoords"), vertexCoordsBuffer[lod].itemSize, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexNormal"));
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer[lod]);
            gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexNormal"), vertexNormalBuffer[lod].itemSize, gl.FLOAT, false, 0, 0);

            gl.uniform3f(gl.getUniformLocation(shaderProgram, "uLightPosition"), lightX, lightY, lightZ);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer);
            gl.uniform1i(gl.getUniformLocation(shaderProgram, "uSampler"), 0);

            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix2));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix2)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer2);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix3));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix3)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer3);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix4));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix4)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer4);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix5));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix5)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer5);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix6));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix6)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer6);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix7));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix7)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer7);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix8));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix8)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer8);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix"), false, new Float32Array(uMVMatrix9));
            gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "uMMatrix2"), false, new Float32Array(MatrixTransposeInverse(uMVMatrix9)));
            gl.bindTexture(gl.TEXTURE_2D, textureBuffer9);
            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer[lod].numItems * vertexPositionBuffer[lod].itemSize);

            setTimeout(Tick, 3);
        }

        function handlekeydown(e) {

            if (e.keyCode === 87) tz += 1;
            if (e.keyCode === 83) tz -= 1;
            if (e.keyCode === 68) angleY = angleY + 1.0;
            if (e.keyCode === 65) angleY = angleY - 1.0;
            if (e.keyCode === 81) angleZ = angleZ + 1.0;
            if (e.keyCode === 69) angleZ = angleZ - 1.0;


            if (e.keyCode === 76) lightX = lightX + 0.1;
            if (e.keyCode === 74) lightX = lightX - 0.1;
            if (e.keyCode === 73) lightY = lightY + 0.1;
            if (e.keyCode === 75) lightY = lightY - 0.1;
            if (e.keyCode === 85) lightZ = lightZ + 0.1;
            if (e.keyCode === 79) lightZ = lightZ - 0.1;
        }
    </script>
</head>

<body onload="startGL()" onkeydown="handlekeydown(event)">
<canvas id="canvas3D" width="1280" height="768"
        style="border: solid black 1px; background-image:url('background.jpg'); background-size: cover;"></canvas>
<div> Sterowanie:
    <ul>
        <li>Klinkięcie w Canvas i ruszanie myszką - poruszanie wokół osi X i Y układu słoneczego</li>
        <li>W / S - Zoom-in / Zoom-out</li>
        <li>E / Q - Poruszanie wokół osi Z układem</li>
        <li>I / K, J/L - Sterowanie światełkiem</li>
    </ul>
</div>
</body>

</html>